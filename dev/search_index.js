var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Regressors","page":"API","title":"Regressors","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"EvoLinearRegressor\nEvoSplineRegressor","category":"page"},{"location":"api/#EvoLinear.Linear.EvoLinearRegressor","page":"API","title":"EvoLinear.Linear.EvoLinearRegressor","text":"EvoLinearRegressor(; kwargs...)\n\nA model type for constructing a EvoLinearRegressor, based on EvoLinear.jl, and implementing both an internal API and the MLJ model interface.\n\nKeyword arguments\n\nloss=:mse: loss function to be minimised.    Can be one of:\n:mse\n:logistic\n:poisson\n:gamma\n:tweedie\nnrounds=10: maximum number of training rounds.\neta=1: Learning rate. Typically in the range [1e-2, 1].\nL1=0: Regularization penalty applied by shrinking to 0 weight update if update is < L1. No penalty if update > L1. Results in sparse feature selection. Typically in the [0, 1] range on normalized features.\nL2=0: Regularization penalty applied to the squared of the weight update value. Restricts large parameter values. Typically in the [0, 1] range on normalized features.\nrng=123: random seed. Not used at the moment.\nupdater=:all: training method. Only :all is supported at the moment. Gradients for each feature are computed simultaneously, then bias is updated based on all features update. \ndevice=:cpu: Only :cpu is supported at the moment.\n\nInternal API\n\nDo config = EvoLinearRegressor() to construct an hyper-parameter struct with default hyper-parameters. Provide keyword arguments as listed above to override defaults, for example:\n\nEvoLinearRegressor(loss=:logistic, L1=1e-3, L2=1e-2, nrounds=100)\n\nTraining model\n\nA model is built using fit:\n\nconfig = EvoLinearRegressor()\nm = fit(config; x, y, w)\n\nInference\n\nFitted results is an EvoLinearModel which acts as a prediction function when passed a features matrix as argument.  \n\npreds = m(x)\n\nMLJ Interface\n\nFrom MLJ, the type can be imported using:\n\nEvoLinearRegressor = @load EvoLinearRegressor pkg=EvoLinear\n\nDo model = EvoLinearRegressor() to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in EvoLinearRegressor(loss=...).\n\nTraining model\n\nIn MLJ or MLJBase, bind an instance model to data with mach = machine(model, X, y) where: \n\nX: any table of input features (eg, a DataFrame) whose columns each have one of the following element scitypes: Continuous, Count, or <:OrderedFactor; check column scitypes with schema(X)\ny: is the target, which can be any AbstractVector whose element scitype is <:Continuous; check the scitype with scitype(y)\n\nTrain the machine using fit!(mach, rows=...).\n\nOperations\n\npredict(mach, Xnew): return predictions of the target given\n\nfeatures Xnew having the same scitype as X above. Predictions   are deterministic.\n\nFitted parameters\n\nThe fields of fitted_params(mach) are:\n\n:fitresult: the EvoLinearModel object returned by EvoLnear.jl fitting algorithm.\n\nReport\n\nThe fields of report(mach) are:\n\n:coef: Vector of coefficients (βs) associated to each of the features.\n:bias: Value of the bias.\n:names: Names of each of the features.\n\n\n\n\n\n","category":"type"},{"location":"api/#EvoLinear.Splines.EvoSplineRegressor","page":"API","title":"EvoLinear.Splines.EvoSplineRegressor","text":"EvoSplineRegressor(; kwargs...)\n\nA model type for constructing a EvoSplineRegressor, based on EvoLinear.jl, and implementing both an internal API and the MLJ model interface.\n\nKeyword arguments\n\nloss=:mse: loss function to be minimised.    Can be one of:\n:mse\n:logistic\n:poisson\n:gamma\n:tweedie\nnrounds=10: maximum number of training rounds.\neta=1: Learning rate. Typically in the range [1e-2, 1].\nL1=0: Regularization penalty applied by shrinking to 0 weight update if update is < L1. No penalty if update > L1. Results in sparse feature selection. Typically in the [0, 1] range on normalized features.\nL2=0: Regularization penalty applied to the squared of the weight update value. Restricts large parameter values. Typically in the [0, 1] range on normalized features.\nrng=123: random seed. Not used at the moment.\nupdater=:all: training method. Only :all is supported at the moment. Gradients for each feature are computed simultaneously, then bias is updated based on all features update. \ndevice=:cpu: Only :cpu is supported at the moment.\n\nInternal API\n\nDo config = EvoSplineRegressor() to construct an hyper-parameter struct with default hyper-parameters. Provide keyword arguments as listed above to override defaults, for example:\n\nEvoSplineRegressor(loss=:logistic, L1=1e-3, L2=1e-2, nrounds=100)\n\nTraining model\n\nA model is built using fit:\n\nconfig = EvoSplineRegressor()\nm = fit(config; x, y, w)\n\nInference\n\nFitted results is an EvoLinearModel which acts as a prediction function when passed a features matrix as argument.  \n\npreds = m(x)\n\nMLJ Interface\n\nFrom MLJ, the type can be imported using:\n\nEvoSplineRegressor = @load EvoSplineRegressor pkg=EvoLinear\n\nDo model = EvoLinearRegressor() to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in EvoSplineRegressor(loss=...).\n\nTraining model\n\nIn MLJ or MLJBase, bind an instance model to data with mach = machine(model, X, y) where: \n\nX: any table of input features (eg, a DataFrame) whose columns each have one of the following element scitypes: Continuous, Count, or <:OrderedFactor; check column scitypes with schema(X)\ny: is the target, which can be any AbstractVector whose element scitype is <:Continuous; check the scitype with scitype(y)\n\nTrain the machine using fit!(mach, rows=...).\n\nOperations\n\npredict(mach, Xnew): return predictions of the target given\n\nfeatures Xnew having the same scitype as X above. Predictions   are deterministic.\n\nFitted parameters\n\nThe fields of fitted_params(mach) are:\n\n:fitresult: the SplineModel object returned by EvoSplineRegressor fitting algorithm.\n\nReport\n\nThe fields of report(mach) are:\n\n:coef: Vector of coefficients (βs) associated to each of the features.\n:bias: Value of the bias.\n:names: Names of each of the features.\n\n\n\n\n\n","category":"type"},{"location":"api/#Training","page":"API","title":"Training","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"EvoLinear.fit","category":"page"},{"location":"api/#MLJModelInterface.fit","page":"API","title":"MLJModelInterface.fit","text":"fit(config::EvoSplineRegressor; x_train, y_train, x_eval = nothing, y_eval = nothing)\n\nTrain a splined linear model. \n\n\n\n\n\nfit(config::EvoLinearRegressor;\n    x, y, w=nothing,\n    x_eval=nothing, y_eval=nothing, w_eval=nothing,\n    metric=:none,\n    print_every_n=1)\n\nProvided a config, EvoLinear.fit takes x and y as features and target inputs, plus optionally w as weights and train a Linear boosted model.\n\nArguments\n\nconfig::EvoLinearRegressor: \n\nKeyword arguments\n\nx::AbstractMatrix: Features matrix. Dimensions are [nobs, num_features].\ny::AbstractVector: Vector of observed targets.\nw=nothing: Vector of weights. Can be be either a Vector or nothing. If nothing, assumes a vector of 1s. \nmetric=nothing: Evaluation metric to be tracked through each iteration. Default to nothing. Can be one of:\n:mse\n:logistic\n:poisson_deviance\n:gamma_deviance\n:tweedie_deviance\n\n\n\n\n\n","category":"function"},{"location":"api/#Metrics","page":"API","title":"Metrics","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [EvoLinear.Metrics]\nOrder   = [:type, :function, :constant]","category":"page"},{"location":"api/#EvoLinear.Metrics.gamma_deviance-Tuple{Any, Any}","page":"API","title":"EvoLinear.Metrics.gamma_deviance","text":"gamma_deviance(p, y)\ngamma_deviance(p, y, w)\n\nGamma deviance evaluation metric. 𝐷 = 2 * (log(μ/y) + y/μ - 1)\n\nArguments\n\np: predicted value. Assumes that p is on a projected basis (ie. in the [0-Inf] range).\ny: observed target variable.\nw: vector of weights.\n\n\n\n\n\n","category":"method"},{"location":"api/#EvoLinear.Metrics.logloss-Tuple{Any, Any}","page":"API","title":"EvoLinear.Metrics.logloss","text":"logloss(p, y)\nlogloss(p, y, w)\n\nLogloss evaluation metric. ylog(p) + (1-y)log(1-p)\n\nArguments\n\np: predicted value. Assumes that p is on a projected basis (ie. in the [0-1] range).\ny: observed target variable.\nw: vector of weights.\n\n\n\n\n\n","category":"method"},{"location":"api/#EvoLinear.Metrics.mae-Tuple{Any, Any}","page":"API","title":"EvoLinear.Metrics.mae","text":"mae(p, y)\nmae(p, y, w)\n\nMean absolute error evaluation metric.\n\nArguments\n\np: predicted value.\ny: observed target variable.\nw: vector of weights.\n\n\n\n\n\n","category":"method"},{"location":"api/#EvoLinear.Metrics.mse-Tuple{Any, Any}","page":"API","title":"EvoLinear.Metrics.mse","text":"mse(p, y)\nmse(p, y, w)\n\nMean squared error evaluation metric.\n\nArguments\n\np: predicted value.\ny: observed target variable.\nw: vector of weights.\n\n\n\n\n\n","category":"method"},{"location":"api/#EvoLinear.Metrics.poisson_deviance-Tuple{Any, Any}","page":"API","title":"EvoLinear.Metrics.poisson_deviance","text":"poisson_deviance(p, y)\npoisson_deviance(p, y, w)\n\nPoisson deviance evaluation metric. 𝐷 = 2 * (y * log(y/p) + p - y)\n\nArguments\n\np: predicted value. Assumes that p is on a projected basis (ie. in the [0-Inf] range).\ny: observed target variable.\nw: vector of weights.\n\n\n\n\n\n","category":"method"},{"location":"api/#EvoLinear.Metrics.tweedie_deviance-Tuple{Any, Any}","page":"API","title":"EvoLinear.Metrics.tweedie_deviance","text":"tweedie_deviance(p, y)\ntweedie_deviance(p, y, w)\n\nTweedie deviance evaluation metric. Fixed rho (ρ) of 1.5. 𝐷 = 2 * (y²⁻ʳʰᵒ/(1-rho)(2-rho) - yμ¹⁻ʳʰᵒ/(1-rho) + μ²⁻ʳʰᵒ/(2-rho))\n\nArguments\n\np: predicted value. Assumes that p is on a projected basis (ie. in the [0-Inf] range).\ny: observed target variable.\nw: vector of weights.\n\n\n\n\n\n","category":"method"},{"location":"#EvoLinear.jl","page":"Home","title":"EvoLinear.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ML library implementing linear boosting with L1 and L2 regularization.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For tree based boosting, consider EvoTrees.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Supported loss functions:","category":"page"},{"location":"","page":"Home","title":"Home","text":"mse (squared-error)\nlogistic (logloss) regression\npoisson\ngamma\ntweedie","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"pkg> add https://github.com/jeremiedb/EvoLinear.jl","category":"page"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Build a configuration struct with EvoLinearRegressor. Then EvoLinear.fit takes x::Matrix and y::Vector as inputs, plus optionally w::Vector as weights and fits a linear boosted model.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using EvoLinear\nconfig = EvoLinearRegressor(loss=:mse, L1=1e-1, L2=1e-2, nrounds=10)\nm = EvoLinear.fit(config; x, y, metric=:mse)\np = EvoLinear.predict_proj(m, x)","category":"page"},{"location":"internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"internals/#Others","page":"Internals","title":"Others","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"EvoLinear.Linear.update_∇!\nEvoLinear.Linear.predict_linear\nEvoLinear.Linear.predict_proj","category":"page"},{"location":"internals/#EvoLinear.Linear.update_∇!","page":"Internals","title":"EvoLinear.Linear.update_∇!","text":"update_∇!(L, ∇¹, ∇², x, y, p, w)\n\nUpdate gradients w.r.t each feature. Each feature gradient update is dispatch according to the loss type (mse, logistic...).\n\n\n\n\n\n","category":"function"},{"location":"internals/#EvoLinear.Linear.predict_linear","page":"Internals","title":"EvoLinear.Linear.predict_linear","text":"predict_linear(m, x)\n\nReturns the predictions on the linear basis from model m using the features matrix x.\n\nArguments\n\nm::EvoLinearModel: model generating the predictions.\nx: features matrix [nobs, num_features] for which predictions are generated.\n\n\n\n\n\n","category":"function"},{"location":"internals/#EvoLinear.Linear.predict_proj","page":"Internals","title":"EvoLinear.Linear.predict_proj","text":"predict_proj(m, x)\n\nReturns the predictions on the projected basis from model m using the features matrix x.\n\nMSE: pred_proj = pred_linear\nLogistic: pred_proj = sigmoid(pred_linear)\nPoisson: pred_proj = exp(pred_linear)\nGamma: pred_proj = exp(pred_linear)\nTweedie: pred_proj = exp(pred_linear)\n\nArguments\n\nm::EvoLinearModel: model generating the predictions.\nx: features matrix [nobs, num_features] for which predictions are generated.\n\n\n\n\n\n","category":"function"}]
}
