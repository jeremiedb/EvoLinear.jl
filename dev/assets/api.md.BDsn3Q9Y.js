import{_ as o,C as r,c as p,o as d,j as s,a as t,aj as n,G as a,w as l}from"./chunks/framework.Dcz_ATK7.js";const M=JSON.parse('{"title":"API","description":"","frontmatter":{},"headers":[],"relativePath":"api.md","filePath":"api.md","lastUpdated":null}'),h={name:"api.md"},c={class:"jldocstring custom-block",open:""},k={class:"jldocstring custom-block",open:""},g={class:"jldocstring custom-block",open:""},u={class:"jldocstring custom-block",open:""},y={class:"jldocstring custom-block",open:""},E={class:"jldocstring custom-block",open:""},b={class:"jldocstring custom-block",open:""},m={class:"jldocstring custom-block",open:""},f={class:"jldocstring custom-block",open:""},v={class:"jldocstring custom-block",open:""};function C(j,e,_,A,T,F){const i=r("Badge");return d(),p("div",null,[e[40]||(e[40]=s("h1",{id:"API",tabindex:"-1"},[t("API "),s("a",{class:"header-anchor",href:"#API","aria-label":'Permalink to "API {#API}"'},"‚Äã")],-1)),e[41]||(e[41]=s("h2",{id:"Regressors",tabindex:"-1"},[t("Regressors "),s("a",{class:"header-anchor",href:"#Regressors","aria-label":'Permalink to "Regressors {#Regressors}"'},"‚Äã")],-1)),s("details",c,[s("summary",null,[e[0]||(e[0]=s("a",{id:"EvoLinear.EvoLinearRegressor",href:"#EvoLinear.EvoLinearRegressor"},[s("span",{class:"jlbinding"},"EvoLinear.EvoLinearRegressor")],-1)),e[1]||(e[1]=t()),a(i,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[3]||(e[3]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">EvoLinearRegressor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(; kwargs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>A model type for constructing a EvoLinearRegressor, based on <a href="https://github.com/jeremiedb/EvoLinear.jl" target="_blank" rel="noreferrer">EvoLinear.jl</a>, and implementing both an internal API and the MLJ model interface.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>loss=:mse</code>: loss function to be minimised. Can be one of:</p><ul><li><p><code>:mse</code></p></li><li><p><code>:logloss</code></p></li><li><p><code>:poisson</code></p></li><li><p><code>:gamma</code></p></li><li><p><code>:tweedie</code></p></li></ul></li><li><p><code>metric</code>: The evaluation metric used to track evaluation data and serves as a basis for early stopping. Supported metrics are:</p><ul><li><p><code>:mse</code>: Mean squared error. Adapted for general regression models.</p></li><li><p><code>:rmse</code>: Root mean squared error. Adapted for general regression models.</p></li><li><p><code>:mae</code>: Mean absolute error. Adapted for general regression models.</p></li><li><p><code>:logloss</code>: Adapted for <code>logistic</code> regression models.</p></li><li><p><code>:poisson</code>: Poisson deviance. Adapted for count models.</p></li><li><p><code>:gamma</code>: Gamma deviance. Adapted to regression problem on Gamma like, positively distributed targets.</p></li><li><p><code>:tweedie</code>: Tweedie deviance. Adapted to regression problem on Tweedie like, positively distributed targets with probability mass at <code>y == 0</code>.</p></li></ul></li><li><p><code>nrounds=10</code>: maximum number of training rounds.</p></li><li><p><code>eta=1</code>: Learning rate. Typically in the range <code>[1e-2, 1]</code>.</p></li><li><p><code>L1=0</code>: Regularization penalty applied by shrinking to 0 weight update if update is &lt; L1. No penalty if update &gt; L1. Results in sparse feature selection. Typically in the <code>[0, 1]</code> range on normalized features.</p></li><li><p><code>L2=0</code>: Regularization penalty applied to the squared of the weight update value. Restricts large parameter values. Typically in the <code>[0, 1]</code> range on normalized features.</p></li><li><p><code>seed::Int=123</code>: random seed.</p></li><li><p><code>updater=:all</code>: training method. Only <code>:all</code> is supported at the moment. Gradients for each feature are computed simultaneously, then bias is updated based on all features update.</p></li></ul><p><strong>Internal API</strong></p><p>Use <code>config = EvoLinearRegressor()</code> to construct an hyper-parameter struct with default hyper-parameters. Provide keyword arguments as listed above to override defaults, for example:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">EvoLinearRegressor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(loss</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:logloss</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, L1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1e-3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, L2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1e-2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, nrounds</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p><strong>Training model</strong></p><p>A model is built using <a href="/EvoLinear.jl/dev/api#MLJModelInterface.fit"><code>fit</code></a>:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">config </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> EvoLinearRegressor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">m </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> fit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(config, date; feature_names, target_name)</span></span></code></pre></div><p><strong>Inference</strong></p><p>Fitted results is an <code>EvoLinearModel</code> which acts as a prediction function when passed a features matrix as argument.</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">preds </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> m</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x)</span></span></code></pre></div><p><strong>MLJ Interface</strong></p><p>From MLJ, the type can be imported using:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">EvoLinearRegressor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> @load</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> EvoLinearRegressor pkg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">EvoLinear</span></span></code></pre></div><p>Do <code>model = EvoLinearRegressor()</code> to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in <code>EvoLinearRegressor(loss=...)</code>.</p><p><strong>Training model</strong></p><p>In MLJ or MLJBase, bind an instance <code>model</code> to data with <code>mach = machine(model, X, y)</code> where:</p><ul><li><p><code>X</code>: any table of input features (eg, a <code>DataFrame</code>) whose columns each have one of the following element scitypes: <code>Continuous</code>, <code>Count</code>, or <code>&lt;:OrderedFactor</code>; check column scitypes with <code>schema(X)</code></p></li><li><p><code>y</code>: is the target, which can be any <code>AbstractVector</code> whose element scitype is <code>&lt;:Continuous</code>; check the scitype with <code>scitype(y)</code></p></li></ul><p>Train the machine using <code>fit!(mach, rows=...)</code>.</p><p><strong>Operations</strong></p><ul><li><code>predict(mach, Xnew)</code>: return predictions of the target given</li></ul><p>features <code>Xnew</code> having the same scitype as <code>X</code> above. Predictions are deterministic.</p><p><strong>Fitted parameters</strong></p><p>The fields of <code>fitted_params(mach)</code> are:</p><ul><li><code>:fitresult</code>: the <code>EvoLinearModel</code> object returned by EvoLnear.jl fitting algorithm.</li></ul><p><strong>Report</strong></p><p>The fields of <code>report(mach)</code> are:</p><ul><li><p><code>:coef</code>: Vector of coefficients (Œ≤s) associated to each of the features.</p></li><li><p><code>:bias</code>: Value of the bias.</p></li><li><p><code>:names</code>: Names of each of the features.</p></li></ul>`,30)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2]||(e[2]=[s("a",{href:"https://github.com/jeremiedb/EvoLinear.jl/blob/48f95c0f76902bdab87d47b529a28bb3187ff8d9/src/structs.jl#L13-L114",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e[42]||(e[42]=s("h2",{id:"Training",tabindex:"-1"},[t("Training "),s("a",{class:"header-anchor",href:"#Training","aria-label":'Permalink to "Training {#Training}"'},"‚Äã")],-1)),s("details",k,[s("summary",null,[e[4]||(e[4]=s("a",{id:"MLJModelInterface.fit",href:"#MLJModelInterface.fit"},[s("span",{class:"jlbinding"},"MLJModelInterface.fit")],-1)),e[5]||(e[5]=t()),a(i,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),e[7]||(e[7]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    learner</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">EvoLinearRegressor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    dtrain;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    feature_names,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    target_name,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    weight_name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    deval</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    metric</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    print_every_n</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">9999</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    early_stopping_rounds</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">9999</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    verbosity</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Provided a <code>config</code>, <code>EvoLinear.fit</code> takes <code>x</code> and <code>y</code> as features and target inputs, plus optionally <code>w</code> as weights and train a Linear boosted model.</p><p><strong>Arguments</strong></p><ul><li><p><code>learner::EvoLinearRegressor</code>:</p></li><li><p><code>dtrain</code>: A <code>Tables.jl</code> compatible table containing the feature, target and optionally weight variables.</p></li></ul><p><strong>Keyword arguments</strong></p><ul><li><p>\`target_name:</p></li><li><p>\`feature_names=nothing:</p></li><li><p>\`weight_name=nothing:</p></li><li><p>\`deval=nothing:</p></li><li><p>\`print_every_n=9999:</p></li><li><p>\`verbosity=1:</p></li></ul>`,6)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[6]||(e[6]=[s("a",{href:"https://github.com/jeremiedb/EvoLinear.jl/blob/48f95c0f76902bdab87d47b529a28bb3187ff8d9/src/fit.jl#L106-L134",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e[43]||(e[43]=s("h2",{id:"Inference",tabindex:"-1"},[t("Inference "),s("a",{class:"header-anchor",href:"#Inference","aria-label":'Permalink to "Inference {#Inference}"'},"‚Äã")],-1)),s("details",g,[s("summary",null,[e[8]||(e[8]=s("a",{id:"MLJModelInterface.predict",href:"#MLJModelInterface.predict"},[s("span",{class:"jlbinding"},"MLJModelInterface.predict")],-1)),e[9]||(e[9]=t()),a(i,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),e[11]||(e[11]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">predict</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(m</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">EvoLinearModel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, data; proj</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Bool</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Predictions from an EvoLinear model.</p>',2)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[10]||(e[10]=[s("a",{href:"https://github.com/jeremiedb/EvoLinear.jl/blob/48f95c0f76902bdab87d47b529a28bb3187ff8d9/src/predict.jl#L1-L5",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e[44]||(e[44]=s("h2",{id:"Metrics",tabindex:"-1"},[t("Metrics "),s("a",{class:"header-anchor",href:"#Metrics","aria-label":'Permalink to "Metrics {#Metrics}"'},"‚Äã")],-1)),s("details",u,[s("summary",null,[e[12]||(e[12]=s("a",{id:"EvoLinear.Metrics.gamma_deviance-Tuple{Any, Any}",href:"#EvoLinear.Metrics.gamma_deviance-Tuple{Any, Any}"},[s("span",{class:"jlbinding"},"EvoLinear.Metrics.gamma_deviance")],-1)),e[13]||(e[13]=t()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[15]||(e[15]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">gamma_deviance</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(p, y)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">gamma_deviance</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(p, y, w)</span></span></code></pre></div><p>Gamma deviance evaluation metric. <code>ùê∑ = 2 * (log(Œº/y) + y/Œº - 1)</code></p><p><strong>Arguments</strong></p><ul><li><p><code>p</code>: predicted value. Assumes that p is on a projected basis (ie. in the <code>[0-Inf]</code> range).</p></li><li><p><code>y</code>: observed target variable.</p></li><li><p><code>w</code>: vector of weights.</p></li></ul>`,4)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[14]||(e[14]=[s("a",{href:"https://github.com/jeremiedb/EvoLinear.jl/blob/48f95c0f76902bdab87d47b529a28bb3187ff8d9/src/metrics.jl#L137-L149",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",y,[s("summary",null,[e[16]||(e[16]=s("a",{id:"EvoLinear.Metrics.logloss-Tuple{Any, Any}",href:"#EvoLinear.Metrics.logloss-Tuple{Any, Any}"},[s("span",{class:"jlbinding"},"EvoLinear.Metrics.logloss")],-1)),e[17]||(e[17]=t()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[19]||(e[19]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">logloss</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(p, y)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">logloss</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(p, y, w)</span></span></code></pre></div><p>Logloss evaluation metric. ylog(p) + (1-y)log(1-p)</p><p><strong>Arguments</strong></p><ul><li><p><code>p</code>: predicted value. Assumes that p is on a projected basis (ie. in the <code>[0-1]</code> range).</p></li><li><p><code>y</code>: observed target variable.</p></li><li><p><code>w</code>: vector of weights.</p></li></ul>`,4)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[18]||(e[18]=[s("a",{href:"https://github.com/jeremiedb/EvoLinear.jl/blob/48f95c0f76902bdab87d47b529a28bb3187ff8d9/src/metrics.jl#L77-L89",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",E,[s("summary",null,[e[20]||(e[20]=s("a",{id:"EvoLinear.Metrics.mae-Tuple{Any, Any}",href:"#EvoLinear.Metrics.mae-Tuple{Any, Any}"},[s("span",{class:"jlbinding"},"EvoLinear.Metrics.mae")],-1)),e[21]||(e[21]=t()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[23]||(e[23]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mae</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(p, y)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mae</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(p, y, w)</span></span></code></pre></div><p>Mean absolute error evaluation metric.</p><p><strong>Arguments</strong></p><ul><li><p><code>p</code>: predicted value.</p></li><li><p><code>y</code>: observed target variable.</p></li><li><p><code>w</code>: vector of weights.</p></li></ul>`,4)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[22]||(e[22]=[s("a",{href:"https://github.com/jeremiedb/EvoLinear.jl/blob/48f95c0f76902bdab87d47b529a28bb3187ff8d9/src/metrics.jl#L50-L61",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",b,[s("summary",null,[e[24]||(e[24]=s("a",{id:"EvoLinear.Metrics.mse-Tuple{Any, Any}",href:"#EvoLinear.Metrics.mse-Tuple{Any, Any}"},[s("span",{class:"jlbinding"},"EvoLinear.Metrics.mse")],-1)),e[25]||(e[25]=t()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[27]||(e[27]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(p, y)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(p, y, w)</span></span></code></pre></div><p>Mean squared error evaluation metric.</p><p><strong>Arguments</strong></p><ul><li><p><code>p</code>: predicted value.</p></li><li><p><code>y</code>: observed target variable.</p></li><li><p><code>w</code>: vector of weights.</p></li></ul>`,4)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[26]||(e[26]=[s("a",{href:"https://github.com/jeremiedb/EvoLinear.jl/blob/48f95c0f76902bdab87d47b529a28bb3187ff8d9/src/metrics.jl#L7-L18",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",m,[s("summary",null,[e[28]||(e[28]=s("a",{id:"EvoLinear.Metrics.poisson_deviance-Tuple{Any, Any}",href:"#EvoLinear.Metrics.poisson_deviance-Tuple{Any, Any}"},[s("span",{class:"jlbinding"},"EvoLinear.Metrics.poisson_deviance")],-1)),e[29]||(e[29]=t()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[31]||(e[31]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">poisson_deviance</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(p, y)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">poisson_deviance</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(p, y, w)</span></span></code></pre></div><p>Poisson deviance evaluation metric. <code>ùê∑ = 2 * (y * log(y/p) + p - y)</code></p><p><strong>Arguments</strong></p><ul><li><p><code>p</code>: predicted value. Assumes that p is on a projected basis (ie. in the <code>[0-Inf]</code> range).</p></li><li><p><code>y</code>: observed target variable.</p></li><li><p><code>w</code>: vector of weights.</p></li></ul>`,4)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[30]||(e[30]=[s("a",{href:"https://github.com/jeremiedb/EvoLinear.jl/blob/48f95c0f76902bdab87d47b529a28bb3187ff8d9/src/metrics.jl#L107-L119",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",f,[s("summary",null,[e[32]||(e[32]=s("a",{id:"EvoLinear.Metrics.rmse-Tuple{Any, Any}",href:"#EvoLinear.Metrics.rmse-Tuple{Any, Any}"},[s("span",{class:"jlbinding"},"EvoLinear.Metrics.rmse")],-1)),e[33]||(e[33]=t()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[35]||(e[35]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">rmse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(p, y)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">rmse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(p, y, w)</span></span></code></pre></div><p>Root-Mean squared error evaluation metric.</p><p><strong>Arguments</strong></p><ul><li><p><code>p</code>: predicted value.</p></li><li><p><code>y</code>: observed target variable.</p></li><li><p><code>w</code>: vector of weights</p></li></ul>`,4)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[34]||(e[34]=[s("a",{href:"https://github.com/jeremiedb/EvoLinear.jl/blob/48f95c0f76902bdab87d47b529a28bb3187ff8d9/src/metrics.jl#L34-L45",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",v,[s("summary",null,[e[36]||(e[36]=s("a",{id:"EvoLinear.Metrics.tweedie_deviance-Tuple{Any, Any}",href:"#EvoLinear.Metrics.tweedie_deviance-Tuple{Any, Any}"},[s("span",{class:"jlbinding"},"EvoLinear.Metrics.tweedie_deviance")],-1)),e[37]||(e[37]=t()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[39]||(e[39]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tweedie_deviance</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(p, y)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tweedie_deviance</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(p, y, w)</span></span></code></pre></div><p>Tweedie deviance evaluation metric. Fixed rho (œÅ) of 1.5. ùê∑ = 2 * (y¬≤‚Åª ≥ ∞·µí/(1-rho)(2-rho) - yŒº¬π‚Åª ≥ ∞·µí/(1-rho) + Œº¬≤‚Åª ≥ ∞·µí/(2-rho))</p><p><strong>Arguments</strong></p><ul><li><p><code>p</code>: predicted value. Assumes that p is on a projected basis (ie. in the <code>[0-Inf]</code> range).</p></li><li><p><code>y</code>: observed target variable.</p></li><li><p><code>w</code>: vector of weights.</p></li></ul>`,4)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[38]||(e[38]=[s("a",{href:"https://github.com/jeremiedb/EvoLinear.jl/blob/48f95c0f76902bdab87d47b529a28bb3187ff8d9/src/metrics.jl#L165-L177",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})])])}const w=o(h,[["render",C]]);export{M as __pageData,w as default};
